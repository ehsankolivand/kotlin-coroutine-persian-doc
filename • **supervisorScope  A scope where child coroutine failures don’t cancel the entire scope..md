# آشنایی با `supervisorScope` در
Kotlin Coroutines

Kotlin Coroutines
به شما کمک می‌کند تا برنامه‌هایی بنویسید که کارها را به طور همزمان و بدون نیاز به انتظار انجام دهند. یکی از ویژگی‌های جالب آن، `supervisorScope` است. این ابزار به شما امکان می‌دهد وظایف همزمان را طوری مدیریت کنید که اگر یکی از آن‌ها دچار خطا شد، بقیه بتوانند کارشان را ادامه دهند. در این مقاله ساده و جذاب، همه چیز درباره `supervisorScope` را یاد می‌گیریم!

---

## `supervisorScope` 
چیست؟

### هدف و نحوه کار
`supervisorScope`
مثل یک مدیر عمل می‌کند که اجازه می‌دهد هر کار (کروروتین) به صورت مستقل اجرا شود. اگر یک کار شکست بخورد، روی بقیه تأثیری نمی‌گذارد. این ویژگی زمانی مفید است که کارها به هم وابسته نیستند و می‌خواهید حتی اگر یکی خراب شد، بقیه کارشان را ادامه دهند.

اگر کدی که داخل `supervisorScope` نوشته‌اید خطایی بدهد، کل این محدوده متوقف می‌شود. اما اگر فقط یکی از کارها (کروروتین‌ها) خطا کند، بقیه ادامه می‌دهند.

### ویژگی‌های اصلی `supervisorScope`
- **مدیریت جداگانه خطاها**: خطای یکی از کارها به کارهای دیگر سرایت نمی‌کند.
- **انعطاف‌پذیری بیشتر**: به شما کمک می‌کند کارها حتی با وجود شکست یک وظیفه، تمام شوند.

**منبع:** [مستندات رسمی Kotlin](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.supervisor-scope.html)

---

## چه زمانی از `supervisorScope` استفاده کنیم؟

### موقعیت‌های واقعی
1. **کارهای مستقل**: وقتی چندین کار جداگانه دارید، مثل فراخوانی همزمان چند API، اگر یکی از آن‌ها خراب شود، بقیه باید ادامه دهند.
   - **مثال:** دانلود اطلاعات کاربر، پست‌ها و نظرات در یک برنامه شبکه اجتماعی.

2. **وظایف رابط کاربری در اندروید**: وقتی چندین کار مرتبط با نمایش در اپلیکیشن دارید، مثل بارگذاری تصاویر، شکست یکی نباید نمایش بقیه را متوقف کند.
   - **مثال:** نمایش گالری عکس، جایی که اگر یکی از تصاویر بارگذاری نشد، بقیه همچنان نمایش داده شوند.

**مثال کد:**
```kotlin
fun fetchData() = runBlocking {
    supervisorScope {
        launch { fetchUserData() } // کار مستقل
        launch { fetchPostsData() } // کار مستقل
        launch { fetchCommentsData() } // ممکن است شکست بخورد
    }
}
```

**منبع:** [Simplified Coding](https://www.simplifiedcoding.net/coroutinescope-vs-supervisorscope-explained/)

---

## تفاوت بین `supervisorScope` و `coroutineScope`

| ویژگی                     | `coroutineScope`                                   | `supervisorScope`                                 |
|-----------------------------|---------------------------------------------------|--------------------------------------------------|
| **مدیریت خطای فرزند**      | همه کارها را متوقف می‌کند اگر یکی شکست بخورد       | بقیه کارها به اجرا ادامه می‌دهند                   |
| **لغو محدوده**             | کل محدوده متوقف می‌شود اگر یکی از کارها خطا کند     | فقط در صورت خطای کد اصلی متوقف می‌شود            |
| **موارد استفاده**          | وقتی کارها به هم وابسته هستند                      | وقتی کارها مستقل از هم هستند                      |

**منبع:** [Outcome School](https://outcomeschool.com/blog/coroutinescope-vs-supervisorscope)

---

## مثال ساده برای `supervisorScope`

### مثال: اجرای کارهای جداگانه
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    supervisorScope {
        val job1 = launch {
            println("شروع کار ۱")
            delay(1000)
            println("کار ۱ تمام شد")
        }

        val job2 = launch {
            println("شروع کار ۲")
            throw Exception("کار ۲ خراب شد") // این خطا روی job1 یا job3 تأثیری ندارد
        }

        val job3 = launch {
            println("شروع کار ۳")
            delay(500)
            println("کار ۳ تمام شد")
        }

        joinAll(job1, job2, job3) // صبر می‌کند تا همه کارها تمام شوند
    }
}
```
**توضیح:**
- کار ۲ خطا می‌دهد، اما کارهای ۱ و ۳ بدون مشکل ادامه پیدا می‌کنند.
- `supervisorScope`
- این امکان را می‌دهد که کل برنامه با وجود خطای یک کار فعال بماند.

**منبع:** [مستندات Kotlin](https://kotlinlang.org/docs/exception-handling.html)

---

## اشتباهات رایج و راه‌حل‌ها

1. **مدیریت نکردن خطاها**: اگر خطاها را مدیریت نکنید، ممکن است مشکلات ناخواسته ایجاد شوند.
   - **راه‌حل:** از `try-catch` یا `CoroutineExceptionHandler` استفاده کنید.

2. **استفاده بیش از حد از `GlobalScope`**: این کار ممکن است باعث نشت حافظه شود.
   - **راه‌حل:** از محدوده‌هایی که با چرخه حیات هماهنگ هستند، مثل `viewModelScope` استفاده کنید.

3. **انتظار موفقیت همه کارها**: حتی با `supervisorScope`، ممکن است بعضی وظایف شکست بخورند.
   - **راه‌حل:** برنامه خود را برای مدیریت شکست‌ها آماده کنید.

**منبع:** [ProAndroidDev](https://proandroiddev.com/comparing-supervisorscope-with-viewmodelscope-understanding-their-use-cases-and-differences-in-ae2726a095bc)

---

## بهترین روش‌ها برای استفاده از `supervisorScope`

1. **از همزمانی ساختاری استفاده کنید**: کروروتین‌ها را در محدوده‌های مشخص اجرا کنید تا حافظه نشت نکند.
2. **خطاها را به درستی مدیریت کنید**: همیشه از `try-catch` یا `CoroutineExceptionHandler` استفاده کنید.
3. **وضعیت کروروتین‌ها را مانیتور کنید**: از متدهایی مثل `invokeOnCompletion` استفاده کنید.
4. **به جای `GlobalScope` از محدوده‌های خاص استفاده کنید**: مثل `viewModelScope` برای مدیریت بهتر چرخه حیات.

**منبع:** [DroidCon](https://www.droidcon.com/2024/10/31/understanding-the-coroutine-lifecycle-in-kotlin/)

---

با استفاده درست از `supervisorScope`، می‌توانید برنامه‌هایی مطمئن‌تر و روان‌تر بسازید. این ابزار به شما کمک می‌کند تا وظایف مستقل را به بهترین شکل مدیریت کنید و برنامه‌هایی مقاوم برای اندروید و دیگر پلتفرم‌ها طراحی کنید.

